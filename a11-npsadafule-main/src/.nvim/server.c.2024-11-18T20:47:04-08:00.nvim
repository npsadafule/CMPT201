#include "server.h"
#include "helper.h"
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <unistd.h>

#define MAX_CLIENTS 100       // Given in instructions
#define MAX_MESSAGE_SIZE 1024 // given in instructions

typedef struct {
  int sockfd;
  struct sockaddr_in addr;
} Client;

typedef struct Message {
  uint8_t data[MAX_MESSAGE_SIZE];
  size_t length;
  struct Message *next;
} Message;

Client clients[MAX_CLIENTS];
int client_count = 0;
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;
int expected_clients = 0;
int termination_count = 0;

Message *message_queue_head = NULL;
Message *message_queue_tail = NULL;
pthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t queue_cond = PTHREAD_COND_INITIALIZER;


void *broadcast_message(void *arg) {
  while (1) {
    pthread_mutex_lock(&queue_mutex);
    while (message_queue_head == NULL) {
      pthread_cond_wait(&queue_cond, &queue_mutex);
    }

    Message *node = message_queue_head;
    message_queue_head = node->next;
    if (message_queue_head == NULL) {
      message_queue_tail = NULL;
    }
    pthread_mutex_unlock(&queue_mutex);

    // Broadcasting message to all clients
    pthread_mutex_lock(&clients_mutex);
    for (int i = 0; i < client_count; i++) {
      if (send(clients[i].sockfd, node->data, node->length, 0) !=
          (ssize_t)node->length) {
        perror("Error broadcasting message");
      }
    }
    pthread_mutex_unlock(&clients_mutex);

    if (node->data[0] == MSG_TYPE_TERMINATE) {
      // Clean up and exit
      free(node);
      break;
    }

    free(node);
  }

  pthread_exit(NULL);
}

int start_server(const char *port_str, int expected_clients_param) {
  expected_clients = expected_clients_param;

  int listen_socket;
  struct sockaddr_in server_address;

  listen_socket = socket(AF_INET, SOCK_STREAM, 0);
  if (listen_socket == -1) {
    perror("Error in socket");
    return -1;
  }

  int opt = 1;
  if (setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
    perror("error in setsockopt");
    close(listen_socket);
    return -1;
  }

  memset(&server_address, 0, sizeof(server_address));
  server_address.sin_family = AF_INET;
  server_address.sin_addr.s_addr = INADDR_ANY; // binding to all interface
  server_address.sin_port = htons(atoi(port_str));

  if (bind(listen_socket, (struct sockaddr *)&server_address,
           sizeof(server_address)) == -1) {
    perror("error in binding");
    return -1;
  }

  if (listen(listen_socket, MAX_CLIENTS) == -1) {
    perror("error in listening");
    close(listen_socket);
    return -1;
  }

  printf("Server listening on port %s\n", port_str);

  // start the broadcasting thread
  pthread_t broadcast_thread;
  if (pthread_create(&broadcast_thread, NULL, broadcast_message, NULL) != 0){
    perror("error in creating broadcaster thread");
    close(listen_socket);
    return -1;
  }

}

void cleanup_server(int listen_socket) {
  close(listen_socket);
  printf("Server shut down");
}

int main(int argc, char *argv[]) {
  if (argc != 3) {
    fprintf(stderr, "Format: ./server <port number> <# of clients>\n");
    exit(EXIT_FAILURE);
  }

  const char *port = argv[1];
  int clients_expected = atoi(argv[2]);

  int listen_socket = start_server(port, clients_expected);
  if (listen_socket == -1) {
    exit(EXIT_FAILURE);
  }

  cleanup_server(listen_socket);
  return 0;
}
